.. _module_cipsi: 
 
.. program:: cipsi 
 
.. default-role:: option 
 
=====
cipsi
=====

|CIPSI| algorithm.

The :c:func:`run_stochastic_cipsi` and :c:func:`run_cipsi` subroutines start with a single
determinant, or with the wave function in the |EZFIO| database if
:option:`determinants read_wf` is |true|.

The :c:func:`run_cipsi` subroutine iteratively:

* Selects the most important determinants from the external space and adds them to the
  internal space
* If :option:`determinants s2_eig` is |true|, it adds all the necessary
  determinants to allow the eigenstates of |H| to be eigenstates of |S^2|
* Diagonalizes |H| in the enlarged internal space
* Computes the |PT2| contribution to the energy stochastically :cite:`Garniron_2017b`
  or deterministically, depending on :option:`perturbation do_pt2`
* Extrapolates the variational energy by fitting
  :math:`E=E_\text{FCI} - \alpha\, E_\text{PT2}`

The difference between :c:func:`run_stochastic_cipsi` and :c:func:`run_cipsi` is that
:c:func:`run_stochastic_cipsi` selects the determinants on the fly with the computation
of the stochastic |PT2| :cite:`Garniron_2017b`. Hence, it is a semi-stochastic selection. It

* Selects the most important determinants from the external space and adds them to the
  internal space, on the fly with the computation of the PT2 with the stochastic algorithm
  presented in :cite:`Garniron_2017b`.
* If :option:`determinants s2_eig` is |true|, it adds all the necessary
  determinants to allow the eigenstates of |H| to be eigenstates of |S^2|
* Extrapolates the variational energy by fitting
  :math:`E=E_\text{FCI} - \alpha\, E_\text{PT2}`
* Diagonalizes |H| in the enlarged internal space


The number of selected determinants at each iteration will be such that the
size of the wave function will double at every iteration. If :option:`determinants
s2_eig` is |true|, then the number of selected determinants will be 1.5x the
current number, and then all the additional determinants will be added.

By default, the program will stop when more than one million determinants have
been selected, or when the |PT2| energy is below :math:`10^{-4}`.

The variational and |PT2| energies of the iterations are stored in the
|EZFIO| database, in the :ref:`module_iterations` module.



Computation of the |PT2| energy
-------------------------------

At each iteration, the |PT2| energy is computed considering the Epstein-Nesbet
zeroth-order Hamiltonian:

.. math::

  E_{\text{PT2}} = \sum_{ \alpha }
    \frac{|\langle \Psi_S | \hat{H} | \alpha \rangle|^2}
         {E - \langle \alpha | \hat{H} | \alpha \rangle}

where the |kalpha| determinants are generated by applying all the single and
double excitation operators to all the determinants of the wave function
:math:`\Psi_G`.

When the hybrid-deterministic/stochastic algorithm is chosen
(default), :math:`Psi_G = \Psi_S = \Psi`, the full wavefunction expanded in the
internal space.
When the deterministic algorithm is chosen (:option:`perturbation do_pt2`
is set to |false|), :math:`Psi_G` is a truncation of |Psi| using
:option:`determinants threshold_generators`, and :math:`Psi_S` is a truncation
of |Psi| using :option:`determinants threshold_selectors`, and re-weighted
by :math:`1/\langle \Psi_s | \Psi_s \rangle`.

At every iteration, while computing the |PT2|, the variance of the wave
function is also computed:

.. math::

  \sigma^2 & = \langle \Psi | \hat{H}^2 | \Psi \rangle -
               \langle  \Psi | \hat{H}   | \Psi \rangle^2 \\
           & = \sum_{i \in \text{FCI}}
               \langle \Psi | \hat{H} | i \rangle
               \langle i | \hat{H} | \Psi \rangle -
               \langle  \Psi | \hat{H} | \Psi \rangle^2 \\
           & = \sum_{ \alpha }
               \langle |\Psi | \hat{H} | \alpha \rangle|^2.

The expression of the variance is the same as the expression of the |PT2|, with
a denominator of 1. It measures how far the wave function is from the |FCI|
solution. Note that the absence of denominator in the Heat-Bath selected |CI|
method is selection method by minimization of the variance, whereas |CIPSI| is
a selection method by minimization of the energy.


If :option:`perturbation do_pt2` is set to |false|, then the stochastic
|PT2| is not computed, and an approximate value is obtained from the |CIPSI|
selection. The calculation is faster, but the extrapolated |FCI| value is
less accurate. This way of running the code should be used when the only
goal is to generate a wave function, as for using |CIPSI| wave functions as
trial wave functions of |QMC| calculations for example.


The :command:`PT2` program reads the wave function of the |EZFIO| database
and computes the energy and the |PT2| contribution.


State-averaging
---------------

Extrapolated |FCI| energy
-------------------------

An estimate of the |FCI| energy is computed by extrapolating

.. math::

  E=E_\text{FCI} - \alpha\, E_\text{PT2}

This extrapolation is done for all the requested states, and excitation
energies are printed as energy differences between the extrapolated
energies of the excited states and the extrapolated energy of the ground
state.

The extrapolations are given considering the 2 last points, the 3 last points, ...,
the 7 last points. The extrapolated value should be chosen such that the extrpolated
value is stable with the number of points.

 
 
 
EZFIO parameters 
---------------- 
 
.. option:: save_wf_after_selection
 
    If true, saves the wave function after the selection, before the diagonalization
 
    Default: False
 
.. option:: seniority_max
 
    Maximum number of allowed open shells. Using -1 selects all determinants
 
    Default: -1
 
.. option:: excitation_ref
 
    1: Hartree-Fock determinant, 2:All determinants of the dominant configuration
 
    Default: 1
 
.. option:: excitation_max
 
    Maximum number of excitation with respect to the Hartree-Fock determinant. Using -1 selects all determinants
 
    Default: -1
 
.. option:: excitation_alpha_max
 
    Maximum number of excitation for alpha determinants with respect to the Hartree-Fock determinant. Using -1 selects all determinants
 
    Default: -1
 
.. option:: excitation_beta_max
 
    Maximum number of excitation for beta determinants with respect to the Hartree-Fock determinant. Using -1 selects all determinants
 
    Default: -1
 
.. option:: twice_hierarchy_max
 
    Twice the maximum hierarchy parameter (excitation degree plus half the seniority number). Using -1 selects all determinants
 
    Default: -1
 
 
Providers 
--------- 
 
.. c:var:: initialize_pt2_e0_denominator


    File : :file:`cipsi/energy.irp.f`

    .. code:: fortran

        logical	:: initialize_pt2_e0_denominator	


    If true, initialize pt2_E0_denominator

    Needed by:

    .. hlist::
       :columns: 3

       * :c:data:`pt2_e0_denominator`

 
.. c:var:: pt2_e0_denominator


    File : :file:`cipsi/energy.irp.f`

    .. code:: fortran

        double precision, allocatable	:: pt2_e0_denominator	(N_states)


    E0 in the denominator of the PT2

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`barycentric_electronic_energy`
       * :c:data:`h0_type`
       * :c:data:`initialize_pt2_e0_denominator`
       * :c:data:`mpi_master`
       * :c:data:`n_states`
       * :c:data:`nuclear_repulsion`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_hii`
       * :c:data:`psi_energy`


 
 
Subroutines / functions 
----------------------- 
 
.. c:function:: bitstring_to_list_in_selection:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine bitstring_to_list_in_selection( string, list, n_elements, Nint)


    Gives the indices(+1) of the bits set to 1 in the bit string

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_pq`
       * :c:func:`spot_isinwf`

 
.. c:function:: fill_buffer_double:


    File : :file:`cipsi/selection.irp.f_template_915`

    .. code:: fortran

        subroutine fill_buffer_double(i_generator, sp, h1, h2, bannedOrb, banned, fock_diag_tmp, E0, pt2_data, mat, buf)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`c0_weight`
       * :c:data:`det_to_configuration`
       * :c:data:`do_only_1h1p`
       * :c:data:`do_ormas`
       * :c:data:`dominant_dets_of_cfgs`
       * :c:data:`elec_alpha_num`
       * :c:data:`excitation_alpha_max`
       * :c:data:`excitation_beta_max`
       * :c:data:`excitation_max`
       * :c:data:`excitation_ref`
       * :c:data:`h0_type`
       * :c:data:`hf_bitmask`
       * :c:data:`mo_integrals_threshold`
       * :c:data:`mo_num`
       * :c:data:`n_dominant_dets_of_cfgs`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`pseudo_sym`
       * :c:data:`psi_configuration_hii`
       * :c:data:`psi_det_generators`
       * :c:data:`psi_det_hii`
       * :c:data:`selection_weight`
       * :c:data:`seniority_max`
       * :c:data:`thresh_sym`
       * :c:data:`twice_hierarchy_max`
       * :c:data:`weight_selection`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_singles_and_doubles`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`add_to_selection_buffer`
       * :c:func:`apply_hole`
       * :c:func:`apply_holes`
       * :c:func:`apply_particle`
       * :c:func:`apply_particles`
       * :c:func:`configuration_to_dets_size`
       * :c:func:`dsyev`
       * :c:func:`get_excitation_degree`
       * :c:func:`get_excitation_degree_spin`

 
.. c:function:: fill_buffer_single:


    File : :file:`cipsi/selection.irp.f_template_915`

    .. code:: fortran

        subroutine fill_buffer_single(i_generator, sp, h1, h2, bannedOrb, banned, fock_diag_tmp, E0, pt2_data, mat, buf)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`c0_weight`
       * :c:data:`det_to_configuration`
       * :c:data:`do_only_1h1p`
       * :c:data:`do_ormas`
       * :c:data:`dominant_dets_of_cfgs`
       * :c:data:`elec_alpha_num`
       * :c:data:`excitation_alpha_max`
       * :c:data:`excitation_beta_max`
       * :c:data:`excitation_max`
       * :c:data:`excitation_ref`
       * :c:data:`h0_type`
       * :c:data:`hf_bitmask`
       * :c:data:`mo_integrals_threshold`
       * :c:data:`mo_num`
       * :c:data:`n_dominant_dets_of_cfgs`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`pseudo_sym`
       * :c:data:`psi_configuration_hii`
       * :c:data:`psi_det_generators`
       * :c:data:`psi_det_hii`
       * :c:data:`selection_weight`
       * :c:data:`seniority_max`
       * :c:data:`thresh_sym`
       * :c:data:`twice_hierarchy_max`
       * :c:data:`weight_selection`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_singles`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`add_to_selection_buffer`
       * :c:func:`apply_hole`
       * :c:func:`apply_holes`
       * :c:func:`apply_particle`
       * :c:func:`apply_particles`
       * :c:func:`configuration_to_dets_size`
       * :c:func:`dsyev`
       * :c:func:`get_excitation_degree`
       * :c:func:`get_excitation_degree_spin`

 
.. c:function:: get_d0:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine get_d0(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_integrals_map`
       * :c:data:`mo_integrals_threshold`
       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_pq`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_particles`
       * :c:func:`get_mo_two_e_integrals`
       * :c:func:`i_h_j`

 
.. c:function:: get_d0_reference:


    File : :file:`cipsi/selection_old.irp.f`

    .. code:: fortran

        subroutine get_d0_reference(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_particles`
       * :c:func:`i_h_j`

 
.. c:function:: get_d1:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine get_d1(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_integrals_map`
       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_pq`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_particles`
       * :c:func:`get_mo_two_e_integrals`
       * :c:func:`i_h_j`

 
.. c:function:: get_d1_reference:


    File : :file:`cipsi/selection_old.irp.f`

    .. code:: fortran

        subroutine get_d1_reference(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_particles`
       * :c:func:`i_h_j`

 
.. c:function:: get_d2:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine get_d2(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_integrals_threshold`
       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_pq`

 
.. c:function:: get_d2_reference:


    File : :file:`cipsi/selection_old.irp.f`

    .. code:: fortran

        subroutine get_d2_reference(gen, phasemask, bannedOrb, banned, mat, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

 
.. c:function:: get_m0:


    File : :file:`cipsi/selection_singles.irp.f`

    .. code:: fortran

        subroutine get_m0(gen, phasemask, bannedOrb, vect, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_p`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_particle`
       * :c:func:`i_h_j`

 
.. c:function:: get_m1:


    File : :file:`cipsi/selection_singles.irp.f`

    .. code:: fortran

        subroutine get_m1(gen, phasemask, bannedOrb, vect, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_p`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_particle`
       * :c:func:`i_h_j`

 
.. c:function:: get_m2:


    File : :file:`cipsi/selection_singles.irp.f`

    .. code:: fortran

        subroutine get_m2(gen, phasemask, bannedOrb, vect, mask, h, p, sp, coefs)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_p`

 
.. c:function:: get_mask_phase:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine get_mask_phase(det1, pm, Nint)



    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`splash_p`
       * :c:func:`splash_pq`

 
.. c:function:: get_phase_bi:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        double precision function get_phase_bi(phasemask, s1, s2, h1, p1, h2, p2, Nint)



 
.. c:function:: provide_for_selection_slave:


    File : :file:`cipsi/run_selection_slave.irp.f`

    .. code:: fortran

        subroutine provide_for_selection_slave



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`psi_det_sorted`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_selectors_coef_transp`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run_selection_slave`

 
.. c:function:: provide_for_zmq_pt2:


    File : :file:`cipsi/pt2_stoch_routines.irp.f`

    .. code:: fortran

        subroutine provide_for_zmq_pt2



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`psi_det_hii`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_selectors_coef_transp`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run_slave_main`
       * :c:func:`zmq_pt2`

 
.. c:function:: run_cipsi:


    File : :file:`cipsi/cipsi.irp.f`

    .. code:: fortran

        subroutine run_cipsi


    Selected Full Configuration Interaction with deterministic selection and
    stochastic PT2.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`correlation_energy_ratio_max`
       * :c:data:`do_pt2`
       * :c:data:`h_apply_buffer_allocated`
       * :c:data:`n_det`
       * :c:data:`n_det_max`
       * :c:data:`n_states`
       * :c:data:`n_states_diag`
       * :c:data:`psi_coef`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_energy`
       * :c:data:`psi_energy_with_nucl_rep`
       * :c:data:`pt2_max`
       * :c:data:`pt2_relative_error`
       * :c:data:`ref_bitmask_energy`
       * :c:data:`s2_eig`
       * :c:data:`save_wf_after_selection`
       * :c:data:`selection_factor`
       * :c:data:`threshold_generators`
       * :c:data:`variance_max`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`check_mem`
       * :c:func:`copy_h_apply_buffer_to_wf`
       * :c:func:`diagonalize_ci`
       * :c:func:`ezfio_get_hartree_fock_energy`
       * :c:func:`ezfio_has_hartree_fock_energy`
       * :c:func:`increment_n_iter`
       * :c:func:`make_s2_eigenfunction`
       * :c:func:`print_extrapolated_energy`
       * :c:func:`print_mol_properties`
       * :c:func:`print_summary`
       * :c:func:`pt2_alloc`
       * :c:func:`pt2_dealloc`
       * :c:func:`save_energy`
       * :c:func:`save_wavefunction`
       * :c:func:`write_cipsi_json`
       * :c:func:`write_double`
       * :c:func:`zmq_pt2`
       * :c:func:`zmq_selection`

    Touches:

    .. hlist::
       :columns: 3

       * :c:data:`ci_electronic_energy`
       * :c:data:`ci_electronic_energy`
       * :c:data:`ci_energy`
       * :c:data:`ci_electronic_energy`
       * :c:data:`psi_configuration`
       * :c:data:`n_det`
       * :c:data:`c0_weight`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_size`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_energy`
       * :c:data:`psi_energy`
       * :c:data:`pt2_match_weight`
       * :c:data:`pt2_overlap`
       * :c:data:`pt2_stoch_istate`
       * :c:data:`selection_weight`
       * :c:data:`state_average_weight`
       * :c:data:`threshold_davidson_pt2`
       * :c:data:`threshold_generators`
       * :c:data:`variance_match_weight`

 
.. c:function:: run_stochastic_cipsi:


    File : :file:`cipsi/stochastic_cipsi.irp.f`

    .. code:: fortran

        subroutine run_stochastic_cipsi(Ev,PT2)


    Selected Full Configuration Interaction with Stochastic selection and PT2.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`correlation_energy_ratio_max`
       * :c:data:`distributed_davidson`
       * :c:data:`h_apply_buffer_allocated`
       * :c:data:`mo_two_e_integrals_in_map`
       * :c:data:`n_det`
       * :c:data:`n_det_max`
       * :c:data:`n_states`
       * :c:data:`n_states_diag`
       * :c:data:`psi_coef`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_energy`
       * :c:data:`psi_energy_with_nucl_rep`
       * :c:data:`pt2_max`
       * :c:data:`pt2_relative_error`
       * :c:data:`ref_bitmask_energy`
       * :c:data:`s2_eig`
       * :c:data:`save_wf_after_selection`
       * :c:data:`selection_factor`
       * :c:data:`threshold_generators`
       * :c:data:`variance_max`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run_optimization_mos_cipsi`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`check_mem`
       * :c:func:`copy_h_apply_buffer_to_wf`
       * :c:func:`diagonalize_ci`
       * :c:func:`ezfio_get_hartree_fock_energy`
       * :c:func:`ezfio_has_hartree_fock_energy`
       * :c:func:`increment_n_iter`
       * :c:func:`make_s2_eigenfunction`
       * :c:func:`print_extrapolated_energy`
       * :c:func:`print_mol_properties`
       * :c:func:`print_summary`
       * :c:func:`pt2_alloc`
       * :c:func:`pt2_dealloc`
       * :c:func:`save_energy`
       * :c:func:`save_wavefunction`
       * :c:func:`write_cipsi_json`
       * :c:func:`write_double`
       * :c:func:`zmq_pt2`

    Touches:

    .. hlist::
       :columns: 3

       * :c:data:`ci_electronic_energy`
       * :c:data:`ci_electronic_energy`
       * :c:data:`ci_energy`
       * :c:data:`ci_electronic_energy`
       * :c:data:`psi_configuration`
       * :c:data:`n_det`
       * :c:data:`c0_weight`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_size`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_energy`
       * :c:data:`psi_energy`
       * :c:data:`pt2_match_weight`
       * :c:data:`pt2_overlap`
       * :c:data:`pt2_stoch_istate`
       * :c:data:`selection_weight`
       * :c:data:`state_average_weight`
       * :c:data:`threshold_davidson_pt2`
       * :c:data:`threshold_generators`
       * :c:data:`variance_match_weight`

 
.. c:function:: select_connected:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine select_connected(i_generator,E0,pt2_data,b,subset,csubset)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`generators_bitmask`
       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_det_generators`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run_pt2_slave_large`
       * :c:func:`run_pt2_slave_small`
       * :c:func:`run_selection_slave`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`build_fock_tmp`
       * :c:func:`select_singles`
       * :c:func:`select_singles_and_doubles`

 
.. c:function:: select_singles:


    File : :file:`cipsi/selection_singles.irp.f`

    .. code:: fortran

        subroutine select_singles(i_gen,hole_mask,particle_mask,fock_diag_tmp,E0,pt2_data,buf)


    Select determinants connected to i_det by H

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_det`
       * :c:data:`n_det_selectors`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_det_generators`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_selectors`
       * :c:data:`psi_selectors_coef_transp`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_connected`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_hole`
       * :c:func:`bitstring_to_list_ab`
       * :c:func:`fill_buffer_single`
       * :c:func:`splash_p`
       * :c:func:`spot_hasbeen`

 
.. c:function:: select_singles_and_doubles:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine select_singles_and_doubles(i_generator, hole_mask, particle_mask, fock_diag_tmp, E0, pt2_data, buf, subset, csubset)


    WARNING /!\ : It is assumed that the generators and selectors are psi_det_sorted

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`banned_excitation`
       * :c:data:`mo_num`
       * :c:data:`n_det`
       * :c:data:`n_det_selectors`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_bilinear_matrix_columns_loc`
       * :c:data:`psi_bilinear_matrix_values`
       * :c:data:`psi_bilinear_matrix_values`
       * :c:data:`psi_bilinear_matrix_transp_values`
       * :c:data:`psi_bilinear_matrix_transp_values`
       * :c:data:`psi_bilinear_matrix_transp_rows_loc`
       * :c:data:`psi_bilinear_matrix_transp_values`
       * :c:data:`psi_bilinear_matrix_values`
       * :c:data:`psi_det_alpha_unique`
       * :c:data:`psi_det_beta_unique`
       * :c:data:`psi_det_generators`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_selectors_coef_transp`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_connected`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`apply_hole`
       * :c:func:`bitstring_to_list_ab`
       * :c:func:`fill_buffer_double`
       * :c:func:`get_excitation_degree_spin`
       * :c:func:`isort_noidx`
       * :c:func:`splash_pq`
       * :c:func:`spot_isinwf`

 
.. c:function:: splash_p:


    File : :file:`cipsi/selection_singles.irp.f`

    .. code:: fortran

        subroutine splash_p(mask, sp, det, coefs, N_sel, bannedOrb, vect)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_det_sorted`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_singles`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list`
       * :c:func:`get_m0`
       * :c:func:`get_m1`
       * :c:func:`get_m2`
       * :c:func:`get_mask_phase`

 
.. c:function:: splash_pq:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine splash_pq(mask, sp, det, i_gen, N_sel, bannedOrb, banned, mat, interesting)


    Computes the contributions A(r,s) by
    comparing the external determinant to all the internal determinants det(i).
    an applying two particles (r,s) to the mask.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_det_sorted`
       * :c:data:`psi_selectors_coef_transp`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_singles_and_doubles`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list_in_selection`
       * :c:func:`get_d0`
       * :c:func:`get_d1`
       * :c:func:`get_d2`
       * :c:func:`get_mask_phase`

 
.. c:function:: spot_hasbeen:


    File : :file:`cipsi/selection_singles.irp.f`

    .. code:: fortran

        subroutine spot_hasBeen(mask, sp, det, i_gen, N, banned, fullMatch)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_singles`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list`

 
.. c:function:: spot_isinwf:


    File : :file:`cipsi/selection.irp.f`

    .. code:: fortran

        subroutine spot_isinwf(mask, det, i_gen, N, banned, fullMatch, interesting)


    Identify the determinants in det that are in the internal space. These are
    the determinants that can be produced by creating two particles on the mask.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`select_singles_and_doubles`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list_in_selection`

 
.. c:function:: write_cipsi_json:


    File : :file:`cipsi/write_cipsi_json.irp.f`

    .. code:: fortran

        subroutine write_cipsi_json(pt2_data, pt2_data_err)


    Writes JSON data for CIPSI runs

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`energy_iterations`
       * :c:data:`json_int_fmt`
       * :c:data:`json_unit`
       * :c:data:`n_det`
       * :c:data:`n_iter`
       * :c:data:`n_states`
       * :c:data:`nsomomax`
       * :c:data:`only_expected_s2`
       * :c:data:`psi_configuration`
       * :c:data:`psi_energy`
       * :c:data:`psi_energy_with_nucl_rep`
       * :c:data:`s2_eig`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run_cipsi`
       * :c:func:`run_stochastic_cipsi`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`lock_io`
       * :c:func:`unlock_io`

