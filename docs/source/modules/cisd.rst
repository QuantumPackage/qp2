.. _module_cisd: 
 
.. program:: cisd 
 
.. default-role:: option 
 
====
cisd
====

This module contains a CI of single and double excitations.

The user point of view
----------------------

The :command:`cisd` program performs the CI of the ROHF-like + all single and double excitations on top of it.
This program can be very useful to :

* **Ground state calculations**: generate a guess for the ground state wave function if one is not sure that the :c:func:`scf` program gave the lowest SCF solution. In combination with :c:func:`save_natorb` it can produce new |MOs| in order to reperform an :c:func:`scf` optimization.

* **Excited states calculations**: generate guess for all the :option:`determinants n_states` wave functions, that will be used by the :c:func:`fci` program.


The main keywords/options to be used are:

* :option:`determinants n_states` : number of states to consider for the |cisd| calculation

* :option:`determinants s2_eig` : force all states to have the desired value of :math:`S^2`

* :option:`determinants expected_s2` : desired value of :math:`S^2`

The programmer point of view
----------------------------

This module have been built by setting the following rules:


* The only generator determinant is the Hartree-Fock (single-reference method)
* All generated determinants are included in the wave function (no perturbative
  selection)

These rules are set in the ``H_apply.irp.f`` file.


 
 
 
EZFIO parameters 
---------------- 
 
.. option:: energy
 
    Variational |CISD| energy
 
 
.. option:: lcc_energy
 
    lccsd energy
 
 
 
Programs 
-------- 
 
 * :ref:`cisd` 
 * :ref:`lccsd` 
 
Providers 
--------- 
 
.. c:var:: lccsd_coef


    File : :file:`lccsd_prov.irp.f`

    .. code:: fortran

        double precision, allocatable	:: lccsd_coef	(N_det,N_states)
        double precision, allocatable	:: lccsd_energies	(N_states)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`big_array_coulomb_integrals`
       * :c:data:`big_array_coulomb_integrals`
       * :c:data:`davidson_sze_max`
       * :c:data:`disk_based_davidson`
       * :c:data:`mo_integrals_map`
       * :c:data:`mo_two_e_integrals_in_map`
       * :c:data:`n_det`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`n_states_diag`
       * :c:data:`nproc`
       * :c:data:`nthreads_davidson`
       * :c:data:`psi_det`
       * :c:data:`qp_max_mem`
       * :c:data:`ref_bitmask`
       * :c:data:`state_following`
       * :c:data:`threshold_davidson`


 
.. c:var:: lccsd_energies


    File : :file:`lccsd_prov.irp.f`

    .. code:: fortran

        double precision, allocatable	:: lccsd_coef	(N_det,N_states)
        double precision, allocatable	:: lccsd_energies	(N_states)



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`big_array_coulomb_integrals`
       * :c:data:`big_array_coulomb_integrals`
       * :c:data:`davidson_sze_max`
       * :c:data:`disk_based_davidson`
       * :c:data:`mo_integrals_map`
       * :c:data:`mo_two_e_integrals_in_map`
       * :c:data:`n_det`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`n_states_diag`
       * :c:data:`nproc`
       * :c:data:`nthreads_davidson`
       * :c:data:`psi_det`
       * :c:data:`qp_max_mem`
       * :c:data:`ref_bitmask`
       * :c:data:`state_following`
       * :c:data:`threshold_davidson`


 
 
Subroutines / functions 
----------------------- 
 
.. c:function:: get_lccsd_2:


    File : :file:`lccsd.irp.f`

    .. code:: fortran

        subroutine get_lccsd_2



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`ha_to_ev`
       * :c:data:`lccsd_coef`
       * :c:data:`n_det`
       * :c:data:`n_states`
       * :c:data:`psi_coef`
       * :c:data:`save_threshold`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`ezfio_set_cisd_lcc_energy`
       * :c:func:`save_wavefunction_truncated`

    Touches:

    .. hlist::
       :columns: 3

       * :c:data:`psi_coef`

 
.. c:function:: h_apply_cisd:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd()


    Calls H_apply on the |HF| determinant and selects all connected single and double
    excitations (of the same symmetry). Auto-generated by the ``generate_h_apply`` script.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`generators_bitmask`
       * :c:data:`h_apply_buffer_allocated`
       * :c:data:`mo_num`
       * :c:data:`mo_two_e_integrals_in_map`
       * :c:data:`n_det`
       * :c:data:`n_det_generators`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_generators`
       * :c:data:`psi_det`
       * :c:data:`psi_det_generators`
       * :c:data:`s2_eig`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run`
       * :c:func:`run_cisd`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`build_fock_tmp`
       * :c:func:`copy_h_apply_buffer_to_wf`
       * :c:func:`dsort`
       * :c:func:`h_apply_cisd_diexc`
       * :c:func:`h_apply_cisd_monoexc`
       * :c:func:`make_s2_eigenfunction`
       * :c:func:`wall_time`

    Touches:

    .. hlist::
       :columns: 3

       * :c:data:`psi_configuration`
       * :c:data:`n_det`
       * :c:data:`c0_weight`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_size`
       * :c:data:`psi_det_sorted_bit`

 
.. c:function:: h_apply_cisd_diexc:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_diexc(key_in, key_prev, hole_1,particl_1, hole_2, particl_2, fock_diag_tmp, i_generator, iproc_in  )



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_det`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_diexcp`

 
.. c:function:: h_apply_cisd_diexcorg:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_diexcOrg(key_in,key_mask,hole_1,particl_1,hole_2, particl_2, fock_diag_tmp, i_generator, iproc_in  )


    Generate all double excitations of key_in using the bit masks of holes and
    particles.
    Assume N_int is already provided.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`elec_alpha_num`
       * :c:data:`mo_num`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_diexcp`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list_ab`
       * :c:func:`fill_h_apply_buffer_no_selection`

 
.. c:function:: h_apply_cisd_diexcp:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_diexcP(key_in, fs1, fh1, particl_1, fs2, fh2, particl_2, fock_diag_tmp, i_generator, iproc_in  )



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_det`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_diexc`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_diexcorg`

 
.. c:function:: h_apply_cisd_monoexc:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_monoexc(key_in, hole_1,particl_1,fock_diag_tmp,i_generator,iproc_in  )


    Generate all single excitations of key_in using the bit masks of holes and
    particles.
    Assume N_int is already provided.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`elec_alpha_num`
       * :c:data:`mo_num`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list_ab`
       * :c:func:`fill_h_apply_buffer_no_selection`

 
.. c:function:: h_apply_cisd_sym:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_sym()


    Calls H_apply on the |HF| determinant and selects all connected single and double
    excitations (of the same symmetry). Auto-generated by the ``generate_h_apply`` script.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`generators_bitmask`
       * :c:data:`h_apply_buffer_allocated`
       * :c:data:`mo_num`
       * :c:data:`mo_two_e_integrals_in_map`
       * :c:data:`n_det`
       * :c:data:`n_det_generators`
       * :c:data:`n_int`
       * :c:data:`n_states`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_generators`
       * :c:data:`psi_det`
       * :c:data:`psi_det_generators`
       * :c:data:`s2_eig`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`run`
       * :c:func:`run_cisd`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`build_fock_tmp`
       * :c:func:`copy_h_apply_buffer_to_wf`
       * :c:func:`dsort`
       * :c:func:`h_apply_cisd_sym_diexc`
       * :c:func:`h_apply_cisd_sym_monoexc`
       * :c:func:`make_s2_eigenfunction`
       * :c:func:`wall_time`

    Touches:

    .. hlist::
       :columns: 3

       * :c:data:`psi_configuration`
       * :c:data:`n_det`
       * :c:data:`c0_weight`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_size`
       * :c:data:`psi_det_sorted_bit`

 
.. c:function:: h_apply_cisd_sym_diexc:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_sym_diexc(key_in, key_prev, hole_1,particl_1, hole_2, particl_2, fock_diag_tmp, i_generator, iproc_in  )



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_det`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_sym`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_sym_diexcp`

 
.. c:function:: h_apply_cisd_sym_diexcorg:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_sym_diexcOrg(key_in,key_mask,hole_1,particl_1,hole_2, particl_2, fock_diag_tmp, i_generator, iproc_in  )


    Generate all double excitations of key_in using the bit masks of holes and
    particles.
    Assume N_int is already provided.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`elec_alpha_num`
       * :c:data:`mo_num`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_sym_diexcp`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list_ab`
       * :c:func:`connected_to_hf`
       * :c:func:`fill_h_apply_buffer_no_selection`

 
.. c:function:: h_apply_cisd_sym_diexcp:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_sym_diexcP(key_in, fs1, fh1, particl_1, fs2, fh2, particl_2, fock_diag_tmp, i_generator, iproc_in  )



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`mo_num`
       * :c:data:`n_det`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_sym_diexc`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_sym_diexcorg`

 
.. c:function:: h_apply_cisd_sym_monoexc:


    File : :file:`h_apply.irp.f_shell_12`

    .. code:: fortran

        subroutine H_apply_cisd_sym_monoexc(key_in, hole_1,particl_1,fock_diag_tmp,i_generator,iproc_in  )


    Generate all single excitations of key_in using the bit masks of holes and
    particles.
    Assume N_int is already provided.

    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`elec_alpha_num`
       * :c:data:`mo_num`
       * :c:data:`n_int`

    Called by:

    .. hlist::
       :columns: 3

       * :c:func:`h_apply_cisd_sym`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`bitstring_to_list_ab`
       * :c:func:`connected_to_hf`
       * :c:func:`fill_h_apply_buffer_no_selection`

 
.. c:function:: run_cisd:


    File : :file:`cisd_routine.irp.f`

    .. code:: fortran

        subroutine run_cisd



    Needs:

    .. hlist::
       :columns: 3

       * :c:data:`ci_electronic_energy`
       * :c:data:`ci_energy`
       * :c:data:`n_det`
       * :c:data:`n_states`
       * :c:data:`pseudo_sym`
       * :c:data:`psi_coef`

    Calls:

    .. hlist::
       :columns: 3

       * :c:func:`ezfio_set_cisd_energy`
       * :c:func:`h_apply_cisd`
       * :c:func:`h_apply_cisd_sym`
       * :c:func:`save_wavefunction`

    Touches:

    .. hlist::
       :columns: 3

       * :c:data:`psi_configuration`
       * :c:data:`n_det`
       * :c:data:`c0_weight`
       * :c:data:`psi_coef`
       * :c:data:`psi_det_sorted_bit`
       * :c:data:`psi_configuration`
       * :c:data:`psi_det`
       * :c:data:`psi_det_size`
       * :c:data:`psi_det_sorted_bit`

