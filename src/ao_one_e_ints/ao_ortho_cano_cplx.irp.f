!todo: add kpts
BEGIN_PROVIDER [ complex*16, ao_cart_to_sphe_coef_complex, (ao_num,ao_cart_to_sphe_num) ]
 implicit none
 BEGIN_DOC
 ! complex version of ao_cart_to_sphe_coef
 END_DOC
 call zlacp2('A',ao_num,ao_cart_to_sphe_num, &
        ao_cart_to_sphe_coef,size(ao_cart_to_sphe_coef,1), &
        ao_cart_to_sphe_coef_complex,size(ao_cart_to_sphe_coef_complex,1))
END_PROVIDER

BEGIN_PROVIDER [ complex*16, ao_cart_to_sphe_overlap_complex, (ao_cart_to_sphe_num,ao_cart_to_sphe_num) ]
 implicit none
 BEGIN_DOC
 ! AO overlap matrix in the spherical basis set
 END_DOC
 complex*16, allocatable :: S(:,:)
 allocate (S(ao_cart_to_sphe_num,ao_num))

 call zgemm('T','N',ao_cart_to_sphe_num,ao_num,ao_num, (1.d0,0.d0), &
   ao_cart_to_sphe_coef_complex,size(ao_cart_to_sphe_coef_complex,1), &
   ao_overlap_complex,size(ao_overlap_complex,1), (0.d0,0.d0), &
   S, size(S,1))

 call zgemm('N','N',ao_cart_to_sphe_num,ao_cart_to_sphe_num,ao_num, (1.d0,0.d0), &
   S, size(S,1), &
   ao_cart_to_sphe_coef_complex,size(ao_cart_to_sphe_coef_complex,1), (0.d0,0.d0), &
   ao_cart_to_sphe_overlap_complex,size(ao_cart_to_sphe_overlap_complex,1))

 deallocate(S)

END_PROVIDER




BEGIN_PROVIDER [ complex*16, ao_ortho_cano_coef_inv_cplx, (ao_num,ao_num)]
 implicit none
 BEGIN_DOC
! ao_ortho_canonical_coef_complex^(-1)
 END_DOC
 call get_inverse_complex(ao_ortho_canonical_coef_complex,size(ao_ortho_canonical_coef_complex,1),&
     ao_num, ao_ortho_cano_coef_inv_cplx, size(ao_ortho_cano_coef_inv_cplx,1))
END_PROVIDER

 BEGIN_PROVIDER [ complex*16, ao_ortho_canonical_coef_complex, (ao_num,ao_num)]
&BEGIN_PROVIDER [ integer, ao_ortho_canonical_num_complex ]
  implicit none
  BEGIN_DOC
! TODO: ao_ortho_canonical_num_complex should be the same as the real version
!       maybe if the providers weren't linked we could avoid making a complex one?
! matrix of the coefficients of the mos generated by the
! orthonormalization by the S^{-1/2} canonical transformation of the aos
! ao_ortho_canonical_coef(i,j) = coefficient of the ith ao on the jth ao_ortho_canonical orbital
  END_DOC
  integer :: i
  ao_ortho_canonical_coef_complex = (0.d0,0.d0)
  do i=1,ao_num
    ao_ortho_canonical_coef_complex(i,i) = (1.d0,0.d0)
  enddo

!call ortho_lowdin(ao_overlap,size(ao_overlap,1),ao_num,ao_ortho_canonical_coef,size(ao_ortho_canonical_coef,1),ao_num)
!ao_ortho_canonical_num=ao_num
!return

  if (ao_cartesian) then

    ao_ortho_canonical_num_complex = ao_num
    call ortho_canonical_complex(ao_overlap,size(ao_overlap,1), &
      ao_num,ao_ortho_canonical_coef_complex,size(ao_ortho_canonical_coef_complex,1), &
      ao_ortho_canonical_num_complex,lin_dep_cutoff)


  else

    complex*16, allocatable :: S(:,:)

    allocate(S(ao_cart_to_sphe_num,ao_cart_to_sphe_num))
    S = (0.d0,0.d0)
    do i=1,ao_cart_to_sphe_num
      S(i,i) = (1.d0,0.d0)
    enddo

    ao_ortho_canonical_num_complex = ao_cart_to_sphe_num
    call ortho_canonical_complex(ao_cart_to_sphe_overlap_complex, size(ao_cart_to_sphe_overlap_complex,1), &
      ao_cart_to_sphe_num, S, size(S,1), ao_ortho_canonical_num_complex,lin_dep_cutoff)

    call zgemm('N','N', ao_num, ao_ortho_canonical_num_complex, ao_cart_to_sphe_num, (1.d0,0.d0), &
      ao_cart_to_sphe_coef_complex, size(ao_cart_to_sphe_coef_complex,1), &
      S, size(S,1), &
      (0.d0,0.d0), ao_ortho_canonical_coef_complex, size(ao_ortho_canonical_coef_complex,1))

    deallocate(S)
  endif
END_PROVIDER

BEGIN_PROVIDER [complex*16, ao_ortho_canonical_overlap_complex, (ao_ortho_canonical_num_complex,ao_ortho_canonical_num_complex)]
  implicit none
  BEGIN_DOC
! overlap matrix of the ao_ortho_canonical.
! Expected to be the Identity
  END_DOC
  integer                        :: i,j,k,l
  complex*16               :: c
  do j=1, ao_ortho_canonical_num_complex
    do i=1, ao_ortho_canonical_num_complex
      ao_ortho_canonical_overlap_complex(i,j) = (0.d0,0.d0)
    enddo
  enddo
  do j=1, ao_ortho_canonical_num_complex
    do k=1, ao_num
      c = (0.d0,0.d0)
      do l=1, ao_num
        c +=  conjg(ao_ortho_canonical_coef_complex(l,j)) * ao_overlap_complex(l,k)
      enddo
      do i=1, ao_ortho_canonical_num_complex
        ao_ortho_canonical_overlap_complex(i,j) += ao_ortho_canonical_coef_complex(k,i) * c
      enddo
    enddo
  enddo
END_PROVIDER
